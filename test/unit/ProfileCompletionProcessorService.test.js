/**
 * Unit tests for Onboarding Checklist Profile Completion Processor Service
 */

process.env.NODE_ENV = 'test'

require('../../src/bootstrap')
const _ = require('lodash')
const should = require('should')
const constants = require('../../src/common/constants')
const { TRAITS_TO_PROFILE_COMPLETION_CHECKLIST_METADATA_MAP } = require('../../src/common/constants')
const logger = require('../../src/common/logger')
const service = require('../../src/services/ProfileCompletionProcessorService')
const {
  testMethods, tonyJUserId, thomasUserId, saarixxUserId
} = require('../common/profileCompletionTestData')
const { nonExistingUserId, upbeatUserId } = require('../common/testData')

describe('Topcoder Onboarding Checklist - Profile Completion Processor Service Unit Tests', () => {
  let infoLogs = []
  let errorLogs = []
  let debugLogs = []
  const info = logger.info
  const error = logger.error
  const debug = logger.debug

  /**
    * Assert validation error
    * @param err the error
    * @param message the message
    */
  function assertValidationError (err, message) {
    err.isJoi.should.be.true()
    should.equal(err.name, 'ValidationError')
    err.details.map(x => x.message).should.containEql(message)
    errorLogs.should.not.be.empty()
  }

  /**
    * Assert there is given info message
    * @param message the message
    */
  function assertInfoMessage (message) {
    infoLogs.should.not.be.empty()
    infoLogs.some(x => String(x).includes(message)).should.be.true()
  }

  /**
    * Assert there is given info message generated by the application logger with structure {component: 'xx', context: 'xx', message: 'xx'}
    * @param message the message
    */
  function assertAppLogInfoMessage (message) {
    infoLogs.should.not.be.empty()
    infoLogs.some(x => String(x.message).includes(message)).should.be.true()
  }

  /**
    * Assert there is given error message
    * @param message the message
    */
  function assertErrorMessage (message) {
    errorLogs.should.not.be.empty()
    errorLogs.some(x => String(x.message).includes(message)).should.be.true()
  }

  /**
    * Assert there is given debug message
    * @param message the message
    */
  function assertDebugMessage (message) {
    debugLogs.should.not.be.empty()
    debugLogs.some(x => String(x.message).includes(message)).should.be.true()
  }

  before(async () => {
    // inject logger with log collector
    logger.info = (message) => {
      infoLogs.push(message)
      info(message)
    }
    logger.error = (message) => {
      errorLogs.push(message)
      error(message)
    }
    logger.debug = (message) => {
      debugLogs.push(message)
      debug(message)
    }
  })

  after(async () => {
    // restore logger
    logger.error = error
    logger.info = info
    logger.debug = debug
  })

  beforeEach(() => {
    // clear logs
    infoLogs = []
    errorLogs = []
    debugLogs = []
  })

  for (const testMethod of _.keys(testMethods)) {
    // Test required fields
    for (const requiredField of testMethods[testMethod].requiredFields) {
      it(`test ${testMethod} with invalid parameters, required field ${requiredField} is missing`, async () => {
        let message = _.cloneDeep(testMethods[testMethod].testMessage)
        message = _.omit(message, requiredField)
        try {
          await service[testMethod](message)
        } catch (err) {
          assertValidationError(err, `"${_.last(requiredField.split('.'))}" is required`)
          return
        }
        throw new Error('should not throw error here')
      })
    }

    // Test string fields
    for (const stringField of testMethods[testMethod].stringFields) {
      it(`test  ${testMethod} with invalid parameters, invalid string type field ${stringField}`, async () => {
        const message = _.cloneDeep(testMethods[testMethod].testMessage)
        _.set(message, stringField, 123)
        try {
          await service[testMethod](message)
        } catch (err) {
          assertValidationError(err, `"${_.last(stringField.split('.'))}" must be a string`)
          return
        }
        throw new Error('should not throw error here')
      })

      it(`test ${testMethod} with invalid parameters, empty string field ${stringField}`, async () => {
        const message = _.cloneDeep(testMethods[testMethod].testMessage)
        _.set(message, stringField, '')
        try {
          await service[testMethod](message)
        } catch (err) {
          assertValidationError(err, `"${_.last(stringField.split('.'))}" is not allowed to be empty`)
          return
        }
        throw new Error('should not throw error here')
      })
    }

    for (const positiveIntegerField of testMethods[testMethod].positiveIntegerFields) {
      it(`test ${testMethod} with invalid parameters, invalid positive integer type field ${positiveIntegerField}`, async () => {
        const message = _.cloneDeep(testMethods[testMethod].testMessage)
        _.set(message, positiveIntegerField, -123)
        try {
          await service[testMethod](message)
        } catch (err) {
          assertValidationError(err, `"${_.last(positiveIntegerField.split('.'))}" must be a positive number`)
          return
        }
        throw new Error('should not throw error here')
      })
    }

    for (const dateField of testMethods[testMethod].dateFields) {
      it(`test ${testMethod} with invalid parameters, invalid date type field ${dateField}`, async () => {
        const message = _.cloneDeep(testMethods[testMethod].testMessage)
        _.set(message, dateField, 'abc')
        try {
          await service[testMethod](message)
        } catch (err) {
          assertValidationError(err,
            `"${_.last(dateField.split('.'))}" must be a number of milliseconds or valid date string`)
          return
        }
        throw new Error('should not throw error here')
      })
    }

    it(`test ${testMethod} with non existing userId`, async () => {
      const message = _.cloneDeep(testMethods[testMethod].testMessage)
      _.set(message, 'payload.userId', nonExistingUserId)
      try {
        await service[testMethod](message)
      } catch (err) {
        assertErrorMessage(`User with id ${nonExistingUserId} does not exist`)
        return
      }
      throw new Error('should not throw error here')
    })
  }

  it('test processProfileUpdateMessage successfully - onboarding checklist already exists without profile completion traits', async () => {
    const message = _.cloneDeep(testMethods['processProfileUpdateMessage'].testMessage)
    _.set(message, 'payload.userId', upbeatUserId)
    await service.processProfileUpdateMessage(message)

    assertDebugMessage(`Process profile completion trait: { user: 'upbeat', updatedMetadata: {"bio":true}}`)
    assertDebugMessage(`Successfully processed profile completion trait { user: 'upbeat', updatedMetadata: {"bio":true}}`)
  })

  it('test processProfileUpdateMessage successfully - onboarding checklist already exists with profile completion traits', async () => {
    const message = _.cloneDeep(testMethods['processProfileUpdateMessage'].testMessage)
    _.set(message, 'payload.userId', tonyJUserId)
    await service.processProfileUpdateMessage(message)

    assertDebugMessage(`Process profile completion trait: { user: 'tonyj', updatedMetadata: {"bio":true}}`)
    assertDebugMessage(`Successfully processed profile completion trait { user: 'tonyj', updatedMetadata: {"bio":true}}`)
  })

  it('test processProfileUpdateMessage successfully - onboarding checklist already exists with profile completion traits - skills not set', async () => {
    const message = _.cloneDeep(testMethods['processProfileUpdateMessage'].testMessage)
    _.set(message, 'payload.userId', thomasUserId)
    await service.processProfileUpdateMessage(message)

    assertDebugMessage(`Process profile completion trait: { user: 'thomaskranitsas', updatedMetadata: {"bio":true}}`)
    assertDebugMessage(`Successfully processed profile completion trait { user: 'thomaskranitsas', updatedMetadata: {"bio":true}}`)
  })

  it('test processProfileUpdateMessage successfully - nothing to update', async () => {
    let message = _.cloneDeep(testMethods['processProfileUpdateMessage'].testMessage)
    _.set(message, 'payload.userId', tonyJUserId)

    delete message.payload.photoURL
    delete message.payload.description

    await service.processProfileUpdateMessage(message)

    assertAppLogInfoMessage(`No update to perform on profile completion trait checklist, Ignoring...!`)
  })

  it('test processCreateOrUpdateProfileTraitMessage with invalid traitId', async () => {
    const message = _.cloneDeep(testMethods['processCreateOrUpdateProfileTraitMessage'].testMessage)
    _.set(message, 'payload.traitId', 'otherTraitId')
    await service.processCreateOrUpdateProfileTraitMessage(message)

    assertInfoMessage(`Event is not for one of valid traitIds : '${_.keys(TRAITS_TO_PROFILE_COMPLETION_CHECKLIST_METADATA_MAP)}' Ignoring ...!`)
  })

  it('test processCreateOrUpdateProfileTraitMessage - all items are set', async () => {
    const message = _.cloneDeep(testMethods['processCreateOrUpdateProfileTraitMessage'].testMessage)
    _.set(message, 'payload.userId', saarixxUserId)
    _.set(message, 'payload.traitId', 'languages')

    await service.processCreateOrUpdateProfileTraitMessage(message)

    assertDebugMessage(`Successfully processed profile completion trait { user: 'saarixx', updatedMetadata: {"${TRAITS_TO_PROFILE_COMPLETION_CHECKLIST_METADATA_MAP['languages']}":true}}`)
  })

  for (const traitId of ['education', 'work', 'languages']) {
    it(`test processCreateOrUpdateProfileTraitMessage with ${traitId} - onboarding checklist does not already exist`, async () => {
      const message = _.cloneDeep(testMethods['processCreateOrUpdateProfileTraitMessage'].testMessage)
      _.set(message, 'payload.traitId', traitId)
      await service.processCreateOrUpdateProfileTraitMessage(message)

      assertDebugMessage(`Process profile completion trait: { user: 'denis', updatedMetadata: {"${TRAITS_TO_PROFILE_COMPLETION_CHECKLIST_METADATA_MAP[traitId]}":true}}`)
      assertDebugMessage(`Successfully processed profile completion trait { user: 'denis', updatedMetadata: {"${TRAITS_TO_PROFILE_COMPLETION_CHECKLIST_METADATA_MAP[traitId]}":true}}`)
    })

    it(`test processCreateOrUpdateProfileTraitMessage with ${traitId} - empty data`, async () => {
      const message = _.cloneDeep(testMethods['processCreateOrUpdateProfileTraitMessage'].testMessage)
      _.set(message, 'payload.traitId', traitId)
      _.set(message, 'payload.traits.data', [])
      await service.processCreateOrUpdateProfileTraitMessage(message)

      assertDebugMessage(`Process profile completion trait: { user: 'denis', updatedMetadata: {"${TRAITS_TO_PROFILE_COMPLETION_CHECKLIST_METADATA_MAP[traitId]}":false}}`)
      assertDebugMessage(`Successfully processed profile completion trait { user: 'denis', updatedMetadata: {"${TRAITS_TO_PROFILE_COMPLETION_CHECKLIST_METADATA_MAP[traitId]}":false}}`)
    })
  }

  it(`test processProfileTraitRemovalMessage - remove onboaring checklist trait `, async () => {
    const message = _.cloneDeep(testMethods['processProfileTraitRemovalMessage'].testMessage)
    _.set(message, 'payload.memberProfileTraitIds', [constants.ONBOARDING_CHECKLIST_TRAIT_ID])

    await service.processProfileTraitRemovalMessage(message)

    assertAppLogInfoMessage(`Onboarding checklist for user { userId: ${_.get(message, 'payload.userId')}} has been removed, Skipping...!`)
  })

  it(`test processProfileTraitRemovalMessage - remove other traits not handled by the processor `, async () => {
    const message = _.cloneDeep(testMethods['processProfileTraitRemovalMessage'].testMessage)
    _.set(message, 'payload.memberProfileTraitIds', ['otherTrait'])

    await service.processProfileTraitRemovalMessage(message)

    assertAppLogInfoMessage(`Profile trait removal message for traitIds: otherTrait Skipped`)
  })

  it('test processProfilePictureUploadMessage with photoURL set', async () => {
    const message = _.cloneDeep(testMethods['processProfilePictureUploadMessage'].testMessage)

    await service.processProfilePictureUploadMessage(message)

    assertDebugMessage(`Process profile completion trait: { user: 'denis', updatedMetadata: {"profile_picture":true}`)
    assertDebugMessage(`Successfully processed profile completion trait { user: 'denis', updatedMetadata: {"profile_picture":true}}`)
  })

  it('test processProfilePictureUploadMessage with empty photoURL', async () => {
    const message = _.cloneDeep(testMethods['processProfilePictureUploadMessage'].testMessage)
    _.set(message, 'payload.photoURL', '')

    await service.processProfilePictureUploadMessage(message)

    assertDebugMessage(`Process profile completion trait: { user: 'denis', updatedMetadata: {"profile_picture":false}`)
    assertDebugMessage(`Successfully processed profile completion trait { user: 'denis', updatedMetadata: {"profile_picture":false}}`)
  })

  it('test processProfilePictureUploadMessage with undefined photoURL', async () => {
    let message = _.cloneDeep(testMethods['processProfilePictureUploadMessage'].testMessage)
    delete message.payload.photoURL

    await service.processProfilePictureUploadMessage(message)

    assertDebugMessage(`Process profile completion trait: { user: 'denis', updatedMetadata: {"profile_picture":false}`)
    assertDebugMessage(`Successfully processed profile completion trait { user: 'denis', updatedMetadata: {"profile_picture":false}}`)
  })

  it('test processProfilePictureUploadMessage with null photoURL', async () => {
    let message = _.cloneDeep(testMethods['processProfilePictureUploadMessage'].testMessage)
    _.set(message, 'payload.photoURL', null)

    await service.processProfilePictureUploadMessage(message)

    assertDebugMessage(`Process profile completion trait: { user: 'denis', updatedMetadata: {"profile_picture":false}`)
    assertDebugMessage(`Successfully processed profile completion trait { user: 'denis', updatedMetadata: {"profile_picture":false}}`)
  })
})
